package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strconv"
)

type AutoGenerated struct {
	//	TestData []struct {
	ClassID    int    `json:"class-id"`
	Name       string `json:"name"`
	TestResult []int  `json:"test-result"`
	Passed     bool   `json:"passed"`
	// } `json:"test-data"`
}

// type AutoGeneratedList struct {
// 	TestDatas []AutoGenerated `json:"TestData"`
// }

// jsonファイルにループで作成したデータを書き込む
func saveJson(file string) bool {

	// 構造体の宣言
	var test_list []AutoGenerated
	var test AutoGenerated
	test.ClassID = 10
	test.Name = "aaa"
	test.TestResult = []int{1, 2, 3}
	test.Passed = true

	for i := 0; i <= 10; i++ {
		fmt.Println(i)

		test.ClassID = i + 1
		test.Name = "user" + strconv.Itoa(i)
		// スライスに一個ずつ追加している
		test_list = append(test_list, test)
	}
	// Marshal スライス→テキスト
	bytes2, _ := json.Marshal(test_list)
	out := new(bytes.Buffer)             // バッファ作成
	json.Indent(out, bytes2, "", "    ") // JSONテキストの成形

	fmt.Println(out.String())

	// ループで出力したデータをjsonに書き込む
	os.WriteFile(file, []byte(out.String()), 0666)
	return true
}

// jsonファイルを読み込む
func readJson(file string) bool {
	// 1単語で意味が分かるような変数名をつける
	bytes, err := os.ReadFile(file)

	if err != nil {
		log.Fatal(err, "読み込みに失敗しました")
		return false
	}
	var test []AutoGenerated

	if err := json.Unmarshal(bytes, &test); err != nil {
		log.Fatal(err, "ファイルが壊れています")
		return false
	}

	//	fmt.Println(string(bytes))
	//	fmt.Println(test)
	//	fmt.Println(test.TestDatas[0].ClassID)
	//	fmt.Println(test.TestDatas[0].Name)

	// ループの種類を覚える何の目的で回してるか
	for i, v := range test {

		fmt.Println("何個目", i)
		fmt.Println(v.ClassID)
		fmt.Println(v.Name)
	}
	return true

}
func main() {
	file := "test-data.json"
	saveResult := saveJson(file)
	readResult := readJson(file)

	if saveResult && readResult {
		fmt.Println("処理に成功しました")
	} else {
		fmt.Println("処理に失敗しました")
	}

}
